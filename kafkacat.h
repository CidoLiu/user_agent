#pragma once

#include <inttypes.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#include <librdkafka/rdkafka.h>


#pragma once

/**
 * Porting
 */

#ifdef _MSC_VER
/* Windows win32 native */

#define WIN32_MEAN_AND_LEAN
#include <Windows.h>

#define RD_NORETURN
#define RD_UNUSED

/* MSVC loves prefixing POSIX functions with underscore */
#define _COMPAT(FUNC)  _ ## FUNC

#define STDIN_FILENO 0

typedef SSIZE_T ssize_t;

ssize_t getdelim (char **bufptr, size_t *n,
				  int delim, FILE *fp);


/**
* @brief gettimeofday() for win32
*/
static RD_UNUSED
int rd_gettimeofday (struct timeval *tv, struct timezone *tz) {
	SYSTEMTIME st;
	FILETIME   ft;
	ULARGE_INTEGER d;

	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &ft);
	d.HighPart = ft.dwHighDateTime;
	d.LowPart = ft.dwLowDateTime;
	tv->tv_sec = (long)((d.QuadPart - 116444736000000000llu) / 10000000L);
	tv->tv_usec = (long)(st.wMilliseconds * 1000);

	return 0;
}


#else
/* POSIX */

#define RD_NORETURN __attribute__((noreturn))
#define RD_UNUSED __attribute__((unused))

#define _COMPAT(FUNC) FUNC

#define rd_gettimeofday(tv,tz) gettimeofday(tv,tz)
#endif


// Automatically generated by ./configure
#pragma once
#define ARCH "x86_64"
#define CPU "generic"
#define WITHOUT_OPTIMIZATION 0
#define WITH_JSON 1
#define MKL_APP_NAME "MKL_APP_NAME"
#define MKL_APP_DESC_ONELINE "MKL_APP_DESC_ONELINE"
// gcc
#define WITH_GCC 1
// install
#define WITH_INSTALL 1
// gitversion
#define KAFKACAT_VERSION "1.3.0-28-gdbc96e"
// librdkafka_ge_090
#define ENABLE_KAFKACONSUMER 1



typedef enum {
    KC_FMT_STR,
    KC_FMT_OFFSET,
    KC_FMT_KEY,
    KC_FMT_KEY_LEN,
    KC_FMT_PAYLOAD,
    KC_FMT_PAYLOAD_LEN,
    KC_FMT_PAYLOAD_LEN_BINARY,
    KC_FMT_TOPIC,
    KC_FMT_PARTITION,
    KC_FMT_TIMESTAMP
} fmt_type_t;

#define KC_FMT_MAX_SIZE  128

struct conf {
    int     run;
    int     verbosity;
    int     exitcode;
    char    mode;
    int     flags;
#define CONF_F_FMT_JSON   0x1 /* JSON formatting */
#define CONF_F_KEY_DELIM  0x2 /* Producer: use key delimiter */
#define CONF_F_OFFSET     0x4 /* Print offsets */
#define CONF_F_TEE        0x8 /* Tee output when producing */
#define CONF_F_NULL       0x10 /* Send empty messages as NULL */
#define CONF_F_LINE	  0x20 /* Read files in line mode when producing */
#define CONF_F_APIVERREQ  0x40 /* Enable api.version.request=true */
#define CONF_F_APIVERREQ_USER 0x80 /* User set api.version.request */
    int     delim;
    int     key_delim;

    struct {
        fmt_type_t type;
        const char *str;
        int         str_len;
    } fmt[KC_FMT_MAX_SIZE];
    int     fmt_cnt;
    int     msg_size;
    char   *brokers;
    char   *topic;
    int32_t partition;
    char   *group;
    int64_t offset;
    int     exit_eof;
    int64_t msg_cnt;
    char   *null_str;
    int     null_str_len;

    rd_kafka_conf_t       *rk_conf;
    rd_kafka_topic_conf_t *rkt_conf;

    rd_kafka_t            *rk;
    rd_kafka_topic_t      *rkt;

    char   *debug;
    int     conf_dump;
};

extern struct conf conf;


void RD_NORETURN fatal0 (const char *func, int line,
                         const char *fmt, ...);

#define FATAL(.../*fmt*/)  fatal0(__FUNCTION__, __LINE__, __VA_ARGS__)

/* Info printout */
#define INFO(VERBLVL,.../*fmt*/) do {                    \
                if (conf.verbosity >= (VERBLVL))     \
                        fprintf(stderr, "%% " __VA_ARGS__);  \
        } while (0)



/*
 * format.c
 */
void fmt_msg_output (FILE *fp, const rd_kafka_message_t *rkmessage);

void fmt_parse (const char *fmt);

void fmt_init (void);
void fmt_term (void);



#if ENABLE_JSON
/*
 * json.c
 */
void fmt_msg_output_json (FILE *fp, const rd_kafka_message_t *rkmessage);
void metadata_print_json (const struct rd_kafka_metadata *metadata);

void fmt_init_json (void);
void fmt_term_json (void);

#endif
